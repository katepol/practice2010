#OrientDB introduction

= OrientDB DBMS =

== Введение ==

OrientDB относится к классу *документо-ориентированных (Documet Store/Document based/Document oriented) СУБД NoSQL*. Документо-ориентированные СУБД хранят коллекции пар ключ/значение, а внутри них рекурсивно коллекции коллекций. Как правило, для представления таких "документов" используются JSON-подобные (см. http://en.wikipedia.org/wiki/JSON), или XML-подобные структуры. В частности, OrientDB использует JSON и XML в оригинальном виде.

В документо-ориентированные БД очень просто осуществить перенос данных из объектно-ориентированного программного обеспечения.

_Rem 1. CouchDB, MongoDB, SimpleDB так же являются документо-ориентированными._ 

_Rem 2. Для обработки связей OrientDB имплементирует особенности графовых хранилищ (GraphDB)._

OrientDB написана на Java, что обеспечивает *кроссплатформенность*.

Позволяет извлекать в графы из сотен связанных объектов быстрее, чем за 1мс, в отличие от реляционных СУБД, использующих дорогостоящие JOIN'ы.

Очень "легкая": полноценный OrientDB сервер занимает около 1Мб места. Не требует дополнительного программного обеспечения и библиотек. 

== Архитектура ==

Как было сказано выше, OrientDB - документо-ориентированная СУБД. На ее основе были созданы Orient Key-Value Server и Orient Object Database.

Класс ODatabase предоставляет основной интерфейс для работы приложений. ODatabase взаимодействует с реализацией класса OStorage, который отвечает за физическое хранение данных. Всего 3 вида реализаций:

 * локальная: запись и чтение that write and read records on the local file system (the access is made in the same process)
 * Remote, that acts as a proxy and send and receive all the requests to a remote OrientDB Server instance
 * Memory, all data remain in memory without to use the file system at all

A Storage is composed by multiple Clusters and Data Segments. You can move real files in your file system only by using the Orient APIs to avoid data corruption.

*Cluster* is very generic way to group records and it's a concept that not exists in the Relational world. You can use a cluster to group all the record of a certain type, or by a specific values.

If you've the background of Relational DBMS world you can start to think to a cluster like a table and use it to group all the records by types.

A cluster can be local or logical.

== CAP ==

В соответствии с CAP теоремой Брюера, OrientDB отвечает требованиям CA. Диаграмма сравнений некоторых СУБД представлена в источнике [4].

*Матрица CAP для OrientDB в зависимости от типа использования*

|| Использование || (C)onsistency || (A)vailability || (P)artition-tolerance ||
|| Локальная БД || + || - || - ||
|| Удаленная БД	|| + || - || - ||
|| Удаленная кластеризованная БД || + || + || - ||
|| Сервер Key-Value || - || + || + ||

== Репликация ==

 * Master-Slaves type, where it can be only one Master and N Slaves. If the Master crashes a Slave is elected to be the new Master
 * IP multicast to discover cluster nodes
 * Configuration of nodes using TCP/IP, useful for Clouds that don't allow the IP multicast
 * Two sync modes: full where all the database is compressed and sent over the network, and partial by sending only the changes happened since the last sync
 * New database handled by the Master OrientDB Server instance to store all the pending records until a configurable threshold. Up this threshold the logs are deleted and the node need a full-sync on startup
 * New console commands to display nodes, listen clustering messages and elect the master manually

== Запросы ==

OrientDB поддерживает запросы на java:
 {{{
 List<ODocument> result = database.query(new ONativeSynchQuery<ODocument, OQueryContextNativeSchema<ODocument>>(database,
                                "Person", new OQueryContextNativeSchema<ODocument>()) {
                        @Override
                        public boolean filter(OQueryContextNativeSchema<ODocument> iRecord) {
                                return iRecord.field("city").field("name").eq("Rome").and().field("name").like("G%").go();
                        };
                });
 }}} 

И SQL-запросы: 
 {{{
 List<ODocument> result = db.query(
  new OSQLSynchQuery<ODocument>("select * from Animal where ID = 10 and name like 'G%'"));
 }}}

Регистр ключевых слов не важен.

_OrientDB поддерживает ACID транзакции._

=== Disk-write strategies ===

Orient, by default, is configured for synchronous writes but depending by the OS file system management changes can be permanents only after the OS flushes the buffer into the disk. If you're using a transaction you're protect in case any crash happens when data are not written to the disk yet.

For this reason Orient permits to change this policy.

*Synchronize all changes to the disk when any single-record is changed*

Bye default is false.

*Synchronize all changes to the disk when a transaction is committed*

Bye default is true.

== Интерфейсы доступа (APIs) ==

=== RESTful HTTP ===
OrientDB RESTful HTTP протокол позволяет обращаться к OrientDB серверу по HTTP протоколу.

OrientDB RESTful HTTP протокол использует 4 метода протокола HTTP:
 # GET - извлечение данных из базы,
 # POST - вставка данных в базу,
 # PUT - изменение данных в базе (update),
 # DELETE - удаление данных из базы.

Результаты - в формате JSON.

=== Java API ===
Для передачи данных между приложением и сервером OrientDB используется улучшенный протокол двоичной синхронной передачи данных для повышения производительности.

Доступ к БД реализован через Java API (c поддержкой схемы данных (full-schema mode)) или просто через  ODatabaseDocumentPool (без схемы (less-schema mode)).

= ВЫВОД =
СУБД OrientDB следует использовать в том, случае, когда нужна 



= Источники =
 # http://nosql-database.org/ 
 # http://www.slideshare.net/lvca/orient-db-introduction 
 # http://www.orientechnologies.com/orient-db.htm
 # http://blog.nahurst.com/visual-guide-to-nosql-systems
 # http://blogerator.ru/page/nosql-vvedenie-v-teoriju-bd